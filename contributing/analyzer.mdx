---
title: Analyzer
description: "What CodeGraph extracts from your codebase"
---

The analyzer is the first layer of CodeGraph. It parses your source code and extracts a graph of **nodes** (code entities) and **edges** (relationships between them).

## How It Works

<Steps>
  <Step title="Open Solution">
    Roslyn opens your `.sln` file and compiles all projects
  </Step>
  <Step title="Traverse Symbols">
    Walk through namespaces, types, and members in the symbol tree
  </Step>
  <Step title="Extract Nodes">
    Create a node for each code entity with its properties
  </Step>
  <Step title="Extract Edges">
    Identify relationships between nodes (inheritance, calls, references)
  </Step>
</Steps>

## Node Types

Nodes represent code entities in your codebase. CodeGraph extracts 18 different node types:

| Category | Type | Description |
|----------|------|-------------|
| <span style={{color: '#3b82f6'}}>Container</span> | `Namespace` | Logical grouping of types |
| <span style={{color: '#3b82f6'}}>Container</span> | `Class` | Class definition |
| <span style={{color: '#3b82f6'}}>Container</span> | `Struct` | Value type definition |
| <span style={{color: '#3b82f6'}}>Container</span> | `Interface` | Interface contract |
| <span style={{color: '#3b82f6'}}>Container</span> | `Enum` | Enumeration type |
| <span style={{color: '#3b82f6'}}>Container</span> | `Record` | Record type (C# 9+) |
| <span style={{color: '#22c55e'}}>Member</span> | `Method` | Method definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Constructor` | Constructor definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Property` | Property definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Field` | Field definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Event` | Event definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Indexer` | Indexer definition |
| <span style={{color: '#22c55e'}}>Member</span> | `Operator` | Operator overload |
| <span style={{color: '#f59e0b'}}>Other</span> | `Parameter` | Method/constructor parameter |
| <span style={{color: '#f59e0b'}}>Other</span> | `LocalVariable` | Local variable |
| <span style={{color: '#f59e0b'}}>Other</span> | `EnumMember` | Enum value |
| <span style={{color: '#f59e0b'}}>Other</span> | `Delegate` | Delegate type |
| <span style={{color: '#f59e0b'}}>Other</span> | `Lambda` | Lambda expression |

## Edge Types

Edges represent relationships between nodes:

| Category | Edge | Description | Example |
|----------|------|-------------|---------|
| <span style={{color: '#3b82f6'}}>Structural</span> | `Contains` | Parent contains child | `Namespace` → `Class` |
| <span style={{color: '#3b82f6'}}>Structural</span> | `Inherits` | Class extends base | `AdminUser` → `User` |
| <span style={{color: '#3b82f6'}}>Structural</span> | `Implements` | Type implements interface | `UserService` → `IUserService` |
| <span style={{color: '#3b82f6'}}>Structural</span> | `Overrides` | Method overrides base | `Derived.DoWork()` → `Base.DoWork()` |
| <span style={{color: '#22c55e'}}>Coupling</span> | `Calls` | Method invokes another | `CreateOrder()` → `GetUser()` |
| <span style={{color: '#22c55e'}}>Coupling</span> | `Instantiates` | Creates instance via `new` | `Handler` → `new Service()` |
| <span style={{color: '#22c55e'}}>Coupling</span> | `References` | Type/member reference | Field types, return types, parameters |

<Note>
The `References` edge captures type dependencies from field types, method return types, parameter types, and generic type arguments.
</Note>

<Info>
Additional **DataFlow** edges (`Reads`, `Writes`, `Returns`, `Creates`, `Throws`, `DataFlowsTo`) are planned. See the [Roadmap](/roadmap) for details.
</Info>

## Node Properties

Each node carries properties extracted during analysis:

```json
{
  "id": "MyApp.Services.UserService",
  "name": "UserService",
  "type": "Class",
  "fullName": "MyApp.Services.UserService",
  "filePath": "/src/Services/UserService.cs",
  "namespace": "MyApp.Services",
  "visibility": "Public",
  "isAbstract": false,
  "isStatic": false,
  "isSealed": false
}
```

### Properties by Type

<AccordionGroup>
  <Accordion title="Types (Class, Struct, Interface, Record)">
    - `fullName` - Fully qualified name
    - `visibility` - Public, Internal, Private, Protected
    - `isAbstract` - Abstract class/method
    - `isSealed` - Sealed/final class
    - `isStatic` - Static class
    - `baseType` - Base class (for inheritance)
    - `interfaces` - Implemented interfaces
  </Accordion>

  <Accordion title="Methods & Constructors">
    - `signature` - Full method signature with parameters
    - `returnType` - Return type
    - `visibility` - Access modifier
    - `isStatic` - Static method
    - `isAbstract` - Abstract method
    - `isVirtual` - Virtual method
    - `isOverride` - Override method
    - `isAsync` - Async method
  </Accordion>

  <Accordion title="Properties & Fields">
    - `type` - Property/field type
    - `visibility` - Access modifier
    - `isStatic` - Static member
    - `isReadOnly` - Read-only field or get-only property
    - `isConst` - Constant field
  </Accordion>

  <Accordion title="Parameters">
    - `type` - Parameter type
    - `isRef` - ref parameter
    - `isOut` - out parameter
    - `isParams` - params array
    - `hasDefault` - Has default value
  </Accordion>
</AccordionGroup>

## Filtering

The analyzer only extracts **source symbols**:

- Types and members defined in your code
- No BCL/Framework types (System.String, etc.)
- No compiler-generated members
- No implicit declarations

This keeps the graph focused on your architecture, not the entire .NET ecosystem.

## What's Next?

<CardGroup cols={2}>
  <Card title="Graph Database" icon="database" href="/contributing/graph-database">
    How the graph is stored and queried
  </Card>
  <Card title="Supported Languages" icon="code" href="/concepts/supported-languages">
    Current and planned language support
  </Card>
</CardGroup>
