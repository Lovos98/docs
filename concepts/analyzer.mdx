---
title: Analyzer
description: "What CodeGraph extracts from your codebase"
---

The analyzer is the first layer of CodeGraph. It parses your source code and extracts a graph of **nodes** (code entities) and **edges** (relationships between them).

## How It Works

<Steps>
  <Step title="Open Solution">
    Roslyn opens your `.sln` file and compiles all projects
  </Step>
  <Step title="Traverse Symbols">
    Walk through namespaces, types, and members in the symbol tree
  </Step>
  <Step title="Extract Nodes">
    Create a node for each code entity with its properties
  </Step>
  <Step title="Extract Edges">
    Identify relationships between nodes (inheritance, calls, references)
  </Step>
</Steps>

## Node Types

Nodes represent code entities in your codebase. CodeGraph extracts 19 different node types:

| Category | Type | Description |
|----------|------|-------------|
| ðŸ”µ Container | `Namespace` | Logical grouping of types |
| ðŸ”µ Container | `Class` | Class definition |
| ðŸ”µ Container | `Struct` | Value type definition |
| ðŸ”µ Container | `Interface` | Interface contract |
| ðŸ”µ Container | `Enum` | Enumeration type |
| ðŸ”µ Container | `Record` | Record type (C# 9+) |
| ðŸŸ¢ Member | `Method` | Method definition |
| ðŸŸ¢ Member | `Constructor` | Constructor definition |
| ðŸŸ¢ Member | `Property` | Property definition |
| ðŸŸ¢ Member | `Field` | Field definition |
| ðŸŸ¢ Member | `Event` | Event definition |
| ðŸŸ¢ Member | `Indexer` | Indexer definition |
| ðŸŸ¢ Member | `Operator` | Operator overload |
| ðŸŸ¡ Other | `Parameter` | Method/constructor parameter |
| ðŸŸ¡ Other | `LocalVariable` | Local variable |
| ðŸŸ¡ Other | `EnumMember` | Enum value |
| ðŸŸ¡ Other | `Delegate` | Delegate type |
| ðŸŸ¡ Other | `Lambda` | Lambda expression |

## Edge Types

Edges represent relationships between nodes:

| Category | Edge | Description | Example | Status |
|----------|------|-------------|---------|--------|
| ðŸ”µ Structural | `Contains` | Parent contains child | `Namespace` â†’ `Class` | Implemented |
| ðŸ”µ Structural | `Inherits` | Class extends base | `AdminUser` â†’ `User` | Implemented |
| ðŸ”µ Structural | `Implements` | Type implements interface | `UserService` â†’ `IUserService` | Implemented |
| ðŸ”µ Structural | `Overrides` | Method overrides base | `Derived.DoWork()` â†’ `Base.DoWork()` | Implemented |
| ðŸŸ¢ Coupling | `Calls` | Method invokes another | `CreateOrder()` â†’ `GetUser()` | Implemented |
| ðŸŸ¢ Coupling | `Instantiates` | Creates instance via `new` | `Handler` â†’ `new Service()` | Implemented |
| ðŸŸ¢ Coupling | `References` | Type/member reference | Field types, return types, parameters | Implemented |
| ðŸŸ¡ DataFlow | `Reads` | Accesses field/property value | `GetName()` reads `_name` | Planned |
| ðŸŸ¡ DataFlow | `Writes` | Assigns to field/property | `SetName()` writes `_name` | Planned |
| ðŸŸ¡ DataFlow | `Returns` | Method returns a type | `GetUser()` returns `User` | Planned |
| ðŸŸ¡ DataFlow | `Creates` | Method instantiates a type | `CreateOrder()` creates `Order` | Planned |
| ðŸŸ¡ DataFlow | `Throws` | Method can throw exception | `Validate()` throws `ValidationException` | Planned |
| ðŸŸ¡ DataFlow | `DataFlowsTo` | Data flows from variable A to B | Track through assignments | Planned |

<Note>
The `References` edge captures type dependencies from field types, method return types, parameter types, and generic type arguments.
</Note>

## Node Properties

Each node carries properties extracted during analysis:

```json
{
  "id": "MyApp.Services.UserService",
  "name": "UserService",
  "type": "Class",
  "fullName": "MyApp.Services.UserService",
  "filePath": "/src/Services/UserService.cs",
  "namespace": "MyApp.Services",
  "visibility": "Public",
  "isAbstract": false,
  "isStatic": false,
  "isSealed": false
}
```

### Properties by Type

<AccordionGroup>
  <Accordion title="Types (Class, Struct, Interface, Record)">
    - `fullName` - Fully qualified name
    - `visibility` - Public, Internal, Private, Protected
    - `isAbstract` - Abstract class/method
    - `isSealed` - Sealed/final class
    - `isStatic` - Static class
    - `baseType` - Base class (for inheritance)
    - `interfaces` - Implemented interfaces
  </Accordion>

  <Accordion title="Methods & Constructors">
    - `signature` - Full method signature with parameters
    - `returnType` - Return type
    - `visibility` - Access modifier
    - `isStatic` - Static method
    - `isAbstract` - Abstract method
    - `isVirtual` - Virtual method
    - `isOverride` - Override method
    - `isAsync` - Async method
  </Accordion>

  <Accordion title="Properties & Fields">
    - `type` - Property/field type
    - `visibility` - Access modifier
    - `isStatic` - Static member
    - `isReadOnly` - Read-only field or get-only property
    - `isConst` - Constant field
  </Accordion>

  <Accordion title="Parameters">
    - `type` - Parameter type
    - `isRef` - ref parameter
    - `isOut` - out parameter
    - `isParams` - params array
    - `hasDefault` - Has default value
  </Accordion>
</AccordionGroup>

## Filtering

The analyzer only extracts **source symbols**:

- Types and members defined in your code
- No BCL/Framework types (System.String, etc.)
- No compiler-generated members
- No implicit declarations

This keeps the graph focused on your architecture, not the entire .NET ecosystem.

## What's Next?

<CardGroup cols={2}>
  <Card title="Graph Database" icon="database" href="/concepts/graph-database">
    How the graph is stored and queried
  </Card>
  <Card title="Supported Languages" icon="code" href="/concepts/supported-languages">
    Current and planned language support
  </Card>
</CardGroup>
